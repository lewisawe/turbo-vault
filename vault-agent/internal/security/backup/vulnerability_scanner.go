package security

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

// VulnerabilityScanner performs security vulnerability assessments
type VulnerabilityScanner struct {
	config *ScannerConfig
	client *http.Client
}

// ScannerConfig contains vulnerability scanner configuration
type ScannerConfig struct {
	EnableCVEScanning     bool
	EnableDependencyCheck bool
	EnableConfigScanning  bool
	CVEDatabaseURL        string
	ScanTimeout           time.Duration
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner(config *ScannerConfig) *VulnerabilityScanner {
	if config == nil {
		config = &ScannerConfig{
			EnableCVEScanning:     true,
			EnableDependencyCheck: true,
			EnableConfigScanning:  true,
			CVEDatabaseURL:        "https://cve.circl.lu/api/",
			ScanTimeout:           30 * time.Minute,
		}
	}

	return &VulnerabilityScanner{
		config: config,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

// ScanResult contains the results of a vulnerability scan
type ScanResult struct {
	Timestamp        time.Time         `json:"timestamp"`
	Vulnerabilities  []Vulnerability   `json:"vulnerabilities"`
	Dependencies     []Dependency      `json:"dependencies"`
	ConfigIssues     []ConfigIssue     `json:"config_issues"`
	Summary          ScanSummary       `json:"summary"`
	Recommendations  []string          `json:"recommendations"`
}

// Vulnerability represents a security vulnerability
type Vulnerability struct {
	ID          string    `json:"id"`
	CVE         string    `json:"cve,omitempty"`
	Severity    string    `json:"severity"`
	Score       float64   `json:"score"`
	Description string    `json:"description"`
	Component   string    `json:"component"`
	Version     string    `json:"version"`
	FixVersion  string    `json:"fix_version,omitempty"`
	References  []string  `json:"references"`
	PublishedAt time.Time `json:"published_at"`
}

// Dependency represents a software dependency
type Dependency struct {
	Name            string   `json:"name"`
	Version         string   `json:"version"`
	LatestVersion   string   `json:"latest_version"`
	Vulnerabilities []string `json:"vulnerabilities"`
	License         string   `json:"license"`
	Path            string   `json:"path"`
}

// ConfigIssue represents a configuration security issue
type ConfigIssue struct {
	File        string `json:"file"`
	Line        int    `json:"line"`
	Issue       string `json:"issue"`
	Severity    string `json:"severity"`
	Description string `json:"description"`
	Fix         string `json:"fix"`
}

// ScanSummary provides a summary of scan results
type ScanSummary struct {
	TotalVulnerabilities int `json:"total_vulnerabilities"`
	CriticalCount        int `json:"critical_count"`
	HighCount            int `json:"high_count"`
	MediumCount          int `json:"medium_count"`
	LowCount             int `json:"low_count"`
	DependencyCount      int `json:"dependency_count"`
	ConfigIssueCount     int `json:"config_issue_count"`
}

// PerformScan executes a comprehensive vulnerability scan
func (vs *VulnerabilityScanner) PerformScan(ctx context.Context, targetPath string) (*ScanResult, error) {
	result := &ScanResult{
		Timestamp:       time.Now(),
		Vulnerabilities: []Vulnerability{},
		Dependencies:    []Dependency{},
		ConfigIssues:    []ConfigIssue{},
	}

	// Scan for CVE vulnerabilities
	if vs.config.EnableCVEScanning {
		vulns, err := vs.scanCVEs(ctx, targetPath)
		if err != nil {
			return nil, fmt.Errorf("CVE scanning failed: %w", err)
		}
		result.Vulnerabilities = append(result.Vulnerabilities, vulns...)
	}

	// Scan dependencies
	if vs.config.EnableDependencyCheck {
		deps, err := vs.scanDependencies(ctx, targetPath)
		if err != nil {
			return nil, fmt.Errorf("dependency scanning failed: %w", err)
		}
		result.Dependencies = deps
	}

	// Scan configuration files
	if vs.config.EnableConfigScanning {
		issues, err := vs.scanConfiguration(ctx, targetPath)
		if err != nil {
			return nil, fmt.Errorf("configuration scanning failed: %w", err)
		}
		result.ConfigIssues = issues
	}

	// Generate summary
	result.Summary = vs.generateSummary(result)
	result.Recommendations = vs.generateRecommendations(result)

	return result, nil
}

// scanCVEs scans for known CVE vulnerabilities
func (vs *VulnerabilityScanner) scanCVEs(ctx context.Context, targetPath string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability

	// Get installed packages and versions
	packages, err := vs.getInstalledPackages(targetPath)
	if err != nil {
		return nil, fmt.Errorf("failed to get installed packages: %w", err)
	}

	// Check each package against CVE database
	for _, pkg := range packages {
		vulns, err := vs.checkPackageCVEs(ctx, pkg.Name, pkg.Version)
		if err != nil {
			continue // Log error but continue with other packages
		}
		vulnerabilities = append(vulnerabilities, vulns...)
	}

	return vulnerabilities, nil
}

// getInstalledPackages retrieves list of installed packages
func (vs *VulnerabilityScanner) getInstalledPackages(targetPath string) ([]Dependency, error) {
	var packages []Dependency

	// Check Go modules
	goModPath := filepath.Join(targetPath, "go.mod")
	if _, err := os.Stat(goModPath); err == nil {
		goPackages, err := vs.parseGoMod(goModPath)
		if err == nil {
			packages = append(packages, goPackages...)
		}
	}

	// Check package.json for Node.js
	packageJSONPath := filepath.Join(targetPath, "package.json")
	if _, err := os.Stat(packageJSONPath); err == nil {
		nodePackages, err := vs.parsePackageJSON(packageJSONPath)
		if err == nil {
			packages = append(packages, nodePackages...)
		}
	}

	// Check requirements.txt for Python
	requirementsPath := filepath.Join(targetPath, "requirements.txt")
	if _, err := os.Stat(requirementsPath); err == nil {
		pythonPackages, err := vs.parseRequirementsTxt(requirementsPath)
		if err == nil {
			packages = append(packages, pythonPackages...)
		}
	}

	return packages, nil
}

// parseGoMod parses Go module dependencies
func (vs *VulnerabilityScanner) parseGoMod(path string) ([]Dependency, error) {
	var dependencies []Dependency

	cmd := exec.Command("go", "list", "-m", "-json", "all")
	cmd.Dir = filepath.Dir(path)
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to run go list: %w", err)
	}

	// Parse JSON output
	decoder := json.NewDecoder(strings.NewReader(string(output)))
	for decoder.More() {
		var module struct {
			Path    string `json:"Path"`
			Version string `json:"Version"`
		}
		if err := decoder.Decode(&module); err != nil {
			continue
		}

		dependencies = append(dependencies, Dependency{
			Name:    module.Path,
			Version: module.Version,
			Path:    path,
		})
	}

	return dependencies, nil
}

// parsePackageJSON parses Node.js package dependencies
func (vs *VulnerabilityScanner) parsePackageJSON(path string) ([]Dependency, error) {
	var dependencies []Dependency

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read package.json: %w", err)
	}

	var pkg struct {
		Dependencies    map[string]string `json:"dependencies"`
		DevDependencies map[string]string `json:"devDependencies"`
	}

	if err := json.Unmarshal(data, &pkg); err != nil {
		return nil, fmt.Errorf("failed to parse package.json: %w", err)
	}

	// Add regular dependencies
	for name, version := range pkg.Dependencies {
		dependencies = append(dependencies, Dependency{
			Name:    name,
			Version: strings.TrimPrefix(version, "^~"),
			Path:    path,
		})
	}

	// Add dev dependencies
	for name, version := range pkg.DevDependencies {
		dependencies = append(dependencies, Dependency{
			Name:    name,
			Version: strings.TrimPrefix(version, "^~"),
			Path:    path,
		})
	}

	return dependencies, nil
}

// parseRequirementsTxt parses Python requirements
func (vs *VulnerabilityScanner) parseRequirementsTxt(path string) ([]Dependency, error) {
	var dependencies []Dependency

	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read requirements.txt: %w", err)
	}

	lines := strings.Split(string(data), "\n")
	versionRegex := regexp.MustCompile(`^([a-zA-Z0-9\-_]+)([>=<~!]+)(.+)$`)

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		matches := versionRegex.FindStringSubmatch(line)
		if len(matches) >= 4 {
			dependencies = append(dependencies, Dependency{
				Name:    matches[1],
				Version: matches[3],
				Path:    path,
			})
		}
	}

	return dependencies, nil
}

// checkPackageCVEs checks a package against CVE database
func (vs *VulnerabilityScanner) checkPackageCVEs(ctx context.Context, packageName, version string) ([]Vulnerability, error) {
	// This is a simplified implementation
	// In a real implementation, you would query actual CVE databases like:
	// - National Vulnerability Database (NVD)
	// - GitHub Security Advisory Database
	// - Snyk Vulnerability Database
	// - OSV Database

	var vulnerabilities []Vulnerability

	// Simulate CVE lookup
	knownVulns := map[string][]Vulnerability{
		"github.com/gin-gonic/gin": {
			{
				ID:          "GHSA-h395-qcrw-5vmq",
				CVE:         "CVE-2023-29401",
				Severity:    "medium",
				Score:       5.3,
				Description: "Gin binding vulnerability allowing path traversal",
				Component:   "github.com/gin-gonic/gin",
				Version:     "< 1.9.1",
				FixVersion:  "1.9.1",
				References:  []string{"https://github.com/gin-gonic/gin/security/advisories/GHSA-h395-qcrw-5vmq"},
				PublishedAt: time.Date(2023, 5, 15, 0, 0, 0, 0, time.UTC),
			},
		},
		"express": {
			{
				ID:          "GHSA-rv95-896h-c2vc",
				CVE:         "CVE-2022-24999",
				Severity:    "high",
				Score:       7.5,
				Description: "Express.js open redirect vulnerability",
				Component:   "express",
				Version:     "< 4.17.3",
				FixVersion:  "4.17.3",
				References:  []string{"https://github.com/expressjs/express/security/advisories/GHSA-rv95-896h-c2vc"},
				PublishedAt: time.Date(2022, 3, 25, 0, 0, 0, 0, time.UTC),
			},
		},
	}

	if vulns, exists := knownVulns[packageName]; exists {
		vulnerabilities = append(vulnerabilities, vulns...)
	}

	return vulnerabilities, nil
}

// scanDependencies performs dependency analysis
func (vs *VulnerabilityScanner) scanDependencies(ctx context.Context, targetPath string) ([]Dependency, error) {
	dependencies, err := vs.getInstalledPackages(targetPath)
	if err != nil {
		return nil, err
	}

	// Enhance dependencies with vulnerability information
	for i := range dependencies {
		vulns, err := vs.checkPackageCVEs(ctx, dependencies[i].Name, dependencies[i].Version)
		if err == nil {
			for _, vuln := range vulns {
				dependencies[i].Vulnerabilities = append(dependencies[i].Vulnerabilities, vuln.ID)
			}
		}
	}

	return dependencies, nil
}

// scanConfiguration scans configuration files for security issues
func (vs *VulnerabilityScanner) scanConfiguration(ctx context.Context, targetPath string) ([]ConfigIssue, error) {
	var issues []ConfigIssue

	// Define security patterns to check
	securityPatterns := []struct {
		pattern     *regexp.Regexp
		severity    string
		description string
		fix         string
	}{
		{
			pattern:     regexp.MustCompile(`password\s*=\s*["'].*["']`),
			severity:    "high",
			description: "Hardcoded password found in configuration",
			fix:         "Use environment variables or secure secret management",
		},
		{
			pattern:     regexp.MustCompile(`api[_-]?key\s*=\s*["'].*["']`),
			severity:    "high",
			description: "Hardcoded API key found in configuration",
			fix:         "Use environment variables or secure secret management",
		},
		{
			pattern:     regexp.MustCompile(`debug\s*=\s*true`),
			severity:    "medium",
			description: "Debug mode enabled in configuration",
			fix:         "Disable debug mode in production",
		},
		{
			pattern:     regexp.MustCompile(`ssl\s*=\s*false`),
			severity:    "high",
			description: "SSL/TLS disabled in configuration",
			fix:         "Enable SSL/TLS encryption",
		},
	}

	// Scan configuration files
	configFiles := []string{
		"config.yaml", "config.yml", "config.json",
		"vault.yaml", "vault.yml", "vault.json",
		".env", "docker-compose.yml",
	}

	for _, configFile := range configFiles {
		filePath := filepath.Join(targetPath, configFile)
		if _, err := os.Stat(filePath); os.IsNotExist(err) {
			continue
		}

		fileIssues, err := vs.scanConfigFile(filePath, securityPatterns)
		if err != nil {
			continue // Log error but continue
		}
		issues = append(issues, fileIssues...)
	}

	return issues, nil
}

// scanConfigFile scans a single configuration file
func (vs *VulnerabilityScanner) scanConfigFile(filePath string, patterns []struct {
	pattern     *regexp.Regexp
	severity    string
	description string
	fix         string
}) ([]ConfigIssue, error) {
	var issues []ConfigIssue

	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	lines := strings.Split(string(data), "\n")
	for lineNum, line := range lines {
		for _, p := range patterns {
			if p.pattern.MatchString(line) {
				issues = append(issues, ConfigIssue{
					File:        filePath,
					Line:        lineNum + 1,
					Issue:       p.pattern.String(),
					Severity:    p.severity,
					Description: p.description,
					Fix:         p.fix,
				})
			}
		}
	}

	return issues, nil
}

// generateSummary creates a summary of scan results
func (vs *VulnerabilityScanner) generateSummary(result *ScanResult) ScanSummary {
	summary := ScanSummary{
		TotalVulnerabilities: len(result.Vulnerabilities),
		DependencyCount:      len(result.Dependencies),
		ConfigIssueCount:     len(result.ConfigIssues),
	}

	// Count vulnerabilities by severity
	for _, vuln := range result.Vulnerabilities {
		switch strings.ToLower(vuln.Severity) {
		case "critical":
			summary.CriticalCount++
		case "high":
			summary.HighCount++
		case "medium":
			summary.MediumCount++
		case "low":
			summary.LowCount++
		}
	}

	return summary
}

// generateRecommendations generates security recommendations
func (vs *VulnerabilityScanner) generateRecommendations(result *ScanResult) []string {
	recommendations := []string{
		"Keep all dependencies up to date",
		"Regularly scan for new vulnerabilities",
		"Use automated dependency update tools",
		"Implement security testing in CI/CD pipeline",
		"Follow secure coding practices",
	}

	if result.Summary.CriticalCount > 0 || result.Summary.HighCount > 0 {
		recommendations = append(recommendations, "Address critical and high severity vulnerabilities immediately")
	}

	if result.Summary.ConfigIssueCount > 0 {
		recommendations = append(recommendations, "Review and fix configuration security issues")
	}

	return recommendations
}

// ExportReport exports scan results to various formats
func (vs *VulnerabilityScanner) ExportReport(result *ScanResult, format, outputPath string) error {
	switch strings.ToLower(format) {
	case "json":
		return vs.exportJSON(result, outputPath)
	case "html":
		return vs.exportHTML(result, outputPath)
	case "csv":
		return vs.exportCSV(result, outputPath)
	default:
		return fmt.Errorf("unsupported export format: %s", format)
	}
}

// exportJSON exports results as JSON
func (vs *VulnerabilityScanner) exportJSON(result *ScanResult, outputPath string) error {
	data, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal JSON: %w", err)
	}

	return os.WriteFile(outputPath, data, 0644)
}

// exportHTML exports results as HTML report
func (vs *VulnerabilityScanner) exportHTML(result *ScanResult, outputPath string) error {
	htmlTemplate := `<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Scan Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .summary { background: #f5f5f5; padding: 15px; border-radius: 5px; }
        .vulnerability { margin: 10px 0; padding: 10px; border-left: 4px solid #ccc; }
        .critical { border-left-color: #d32f2f; }
        .high { border-left-color: #f57c00; }
        .medium { border-left-color: #fbc02d; }
        .low { border-left-color: #388e3c; }
    </style>
</head>
<body>
    <h1>Vulnerability Scan Report</h1>
    <div class="summary">
        <h2>Summary</h2>
        <p>Total Vulnerabilities: %d</p>
        <p>Critical: %d, High: %d, Medium: %d, Low: %d</p>
        <p>Dependencies: %d</p>
        <p>Config Issues: %d</p>
    </div>
    <!-- Additional HTML content would be generated here -->
</body>
</html>`

	html := fmt.Sprintf(htmlTemplate,
		result.Summary.TotalVulnerabilities,
		result.Summary.CriticalCount,
		result.Summary.HighCount,
		result.Summary.MediumCount,
		result.Summary.LowCount,
		result.Summary.DependencyCount,
		result.Summary.ConfigIssueCount,
	)

	return os.WriteFile(outputPath, []byte(html), 0644)
}

// exportCSV exports results as CSV
func (vs *VulnerabilityScanner) exportCSV(result *ScanResult, outputPath string) error {
	var lines []string
	lines = append(lines, "Type,ID,Severity,Component,Description")

	for _, vuln := range result.Vulnerabilities {
		line := fmt.Sprintf("Vulnerability,%s,%s,%s,%s",
			vuln.ID, vuln.Severity, vuln.Component, vuln.Description)
		lines = append(lines, line)
	}

	for _, issue := range result.ConfigIssues {
		line := fmt.Sprintf("Config Issue,%s,%s,%s,%s",
			issue.File, issue.Severity, issue.File, issue.Description)
		lines = append(lines, line)
	}

	csv := strings.Join(lines, "\n")
	return os.WriteFile(outputPath, []byte(csv), 0644)
}
